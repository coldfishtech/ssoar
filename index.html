<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>SSOAR: Touch the Sky</title>
  <script src="https://w.soundcloud.com/player/api.js"></script>
  <style>
    html {
      background: #f6f8fb; /* subtle cool off-white */
    }
    body {
      margin: 0;
      background: #f6f8fb; /* subtle cool off-white */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    /* Prevent text/image selection and callouts during drag on mobile/desktop */
    html, body {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      /* Disable vertical dragging, allow only horizontal gestures */
      touch-action: pan-x;
    }
    #titleImage {
      width: 200px; /* 50% of previous 400px */
      max-width: 45vw; /* scale cap proportionally */
      height: auto;
      image-rendering: pixelated;
      margin-bottom: 8px;
      -webkit-user-drag: none;
      user-select: none;
    }
    /* topbar wraps title + musicbar */
    #topbar {
      width: 400px;
      max-width: 90vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
  /* music bar (under title on desktop; next to it on mobile) */
    #musicbar {
      width: 400px;
      max-width: 90vw;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      /* Use the same bold font as the in-game text */
      font-family: Arial Black, Arial, Helvetica, sans-serif;
      font-weight: 900;
    }
  /* SVG play/pause icon (black) */
  #music-icon { width: 16px; height: 16px; cursor: pointer; display: inline-block; }
    #music-icon.disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
    /* Ensure the label matches the icon/scope height visually */
    #music-label {
      font-family: Arial Black, Arial, Helvetica, sans-serif;
      font-weight: 900;
      font-size: 12px;
      color: #222;
      height: 28px;
      display: inline-flex;
      align-items: center;
    }
    /* Tiny frequency visualizer next to the music button */
    #music-scope {
      display: inline-block;
      width: 60px;
      height: 16px; /* match icon height */
      background: transparent;
      border: none !important; /* override global canvas border */
      box-shadow: none;
    }
    
    canvas {
      background: transparent; /* the canvas draws its own sky, page around is off-white */
      image-rendering: pixelated;
      border: 1px solid #b0b7c2; /* subtle cool grey stroke */
      -webkit-user-drag: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none; /* avoid scrolling/zoom while dragging on canvas */
    }
  /* Controls under the canvas (shown on mobile) */
    #controls {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none; /* avoid selecting/scrolling when sliding arrows */
    }
    .ctrl-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 1px solid #b0b7c2;
      background: #222;
      color: #fff;
      font: 24px/56px Arial, sans-serif;
      text-align: center;
      padding: 0;
      cursor: pointer;
      outline: none;
      margin: 0; /* eliminate default button margins */
      -webkit-user-drag: none;
      -webkit-tap-highlight-color: transparent;
    }
    /* arrows: pentagonal via clip-path; remove text visuals */
  .ctrl-arrow {
    /* Replace shape with image buttons */
    width: auto; height: auto; border-radius: 0; font-size: 0; line-height: 0;
    background: transparent; border: none; padding: 0;
    clip-path: none;
    display: inline-flex; align-items: center; justify-content: center;
  }
  .ctrl-arrow img { display: block; image-rendering: pixelated; pointer-events: none; }
  /* legacy shape overrides */
  .ctrl-arrow--right, .ctrl-arrow--left { clip-path: none; }
    /* arrow group: tighter spacing and better touch handling */
    .ctrl-group-arrows {
      display: flex;
      gap: 2px;            /* slight visual separation */
      align-items: center;  /* vertically center differing image heights */
      touch-action: none;   /* allow sliding without triggering page scroll/zoom */
    }
    /* jump: replace with image; keep centers aligned */
    .ctrl-btn--jump {
      width: auto; height: auto;
      background: transparent; border: none;
      font-size: 0; line-height: 0;
      -webkit-appearance: none; appearance: none;
      border-radius: 0;
      clip-path: none;
      padding: 0;
      display: inline-flex; align-items: center; justify-content: center;
    }
    .ctrl-btn--jump img { display: block; image-rendering: pixelated; pointer-events: none; }
    .ctrl-btn:active { filter: brightness(1.15); }

    /* Mobile-friendly layout: let elements span full width and canvas fill viewport remainder */
    @media (max-width: 600px) {
      body {
        align-items: stretch;
        justify-content: flex-start;
        padding: 24px;
        /* Extra bottom padding so bottom browser UI doesn't overlap controls */
        padding-bottom: 72px; /* fallback */
        padding-bottom: calc(72px + env(safe-area-inset-bottom)); /* add safe-area if present */
      }
      #topbar, #controls { width: 100%; max-width: 100%; box-sizing: border-box; }
      /* Place title and musicbar side-by-side on mobile */
      #topbar { flex-direction: row; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
  /* Half-size title image (50% of previous mobile width) */
  #titleImage { width: 100px; max-width: 20vw; margin-bottom: 0; }
      /* Right-align music player so its right edge aligns with canvas right edge */
      #musicbar { margin-left: auto; margin-bottom: 0; box-sizing: border-box; padding: 0 0; gap: 8px; justify-content: flex-end; }
      /* Increase separation between arrow group and jump button */
      #controls { gap: 80px; }
      /* Canvas width will be set via JS; fallback respects body padding */
      canvas { width: 100%; height: auto; }
    }

    /* (removed) name overlay styles */

    /* Start menu overlay */
    #startMenuBackdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: none; /* shown when menu active */
      z-index: 10;
    }
    /* Centered decorative frame image under the menu */
    #startMenuFrame {
      position: fixed;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: min(420px, 92vw);
      height: auto;
      display: none;
      z-index: 11;
      pointer-events: none;
      image-rendering: pixelated;
    }
    #startMenu {
      position: fixed;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      background: transparent; /* use frame image for chrome */
      border: none;
      box-shadow: none;
      border-radius: 0;
      width: min(320px, 78vw);
      padding: 16px;
      display: none; /* shown when menu active */
      z-index: 12; /* above frame */
      font-family: Arial, Helvetica, sans-serif;
      color: #000;
    }
    #startMenu h2 {
      margin: 0 0 12px 0;
      font-weight: 700;
      font-size: 18px;
      text-align: center;
    }
    .menu-row { display: flex; align-items: center; justify-content: space-between; margin: 8px 0; }
    .menu-btn, .menu-toggle {
      border: 1px solid #b0b7c2; background: #222; color: #fff;
      border-radius: 6px; padding: 10px 14px; cursor: pointer; font-weight: 700;
    }
    .menu-toggle { background: #fff; color: #222; }
    .menu-toggle[aria-pressed="true"] { background: #222; color: #fff; }
    .menu-actions { display: flex; justify-content: center; margin-top: 12px; }
    .menu-actions .menu-btn { min-width: 140px; }
  </style>
</head>
<body>
  <div id="topbar">
  <img id="titleImage" src="soar_title.png" alt="SSOAR Title" />
    <div id="musicbar" aria-label="Music Player">
      <span id="music-label">BGM</span>
      <svg id="music-icon" viewBox="0 0 24 24" aria-label="Play BGM" title="Play/Pause BGM" tabindex="-1" role="button" class="disabled" data-state="paused">
        <path id="music-icon-path" fill="#000" d="M8 5v14l11-7z"/>
      </svg>
      <canvas id="music-scope" width="60" height="16" aria-hidden="true"></canvas>
      <!-- hidden SoundCloud widget iframe used for playback/control -->
      <iframe
        id="sc-widget"
        allow="autoplay"
        scrolling="no"
        frameborder="no"
        style="position:absolute; left:-9999px; width:0; height:0; border:0;"
        src="https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/user-385939006/01-ddd&auto_play=false&hide_related=true&show_comments=false&show_user=false&show_reposts=false&visual=false">
      </iframe>
    </div>
  </div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <!-- Start Menu Overlay -->
  <div id="startMenuBackdrop" aria-hidden="true"></div>
  <img id="startMenuFrame" src="resources/frame/frame.png" alt="Frame" aria-hidden="true"/>
  <div id="startMenu" role="dialog" aria-modal="true" aria-labelledby="menuTitle">
    <h2 id="menuTitle">Start Menu</h2>
    <div class="menu-row">
      <span>Music</span>
      <button id="toggle-music" class="menu-toggle" type="button" aria-pressed="false">Off</button>
    </div>
    <div class="menu-row">
      <span>SFX</span>
      <button id="toggle-sfx" class="menu-toggle" type="button" aria-pressed="true">On</button>
    </div>
    <div class="menu-actions">
      <button id="btn-play" class="menu-btn" type="button">Play Game</button>
    </div>
  </div>
  
  <!-- (removed) name entry overlay -->
  
  <!-- Desktop instructions (hidden on mobile) -->
  <div id="desktop-instructions" aria-hidden="true" style="display:none;"></div>
  <div id="controls" aria-label="Game Controls">
    <div id="arrow-group" class="ctrl-group-arrows" aria-label="Directional Controls">
      <button id="btn-left" class="ctrl-btn ctrl-arrow ctrl-arrow--left" aria-label="Move" title="Move" tabindex="-1">
        <img src="resources/buttons/L_button.png" alt="Move">
      </button>
    </div>
    <button id="btn-jump" class="ctrl-btn ctrl-btn--jump" aria-label="Jump" title="Jump" tabindex="-1">
      <img src="resources/buttons/R_button.png" alt="Jump">
    </button>
  </div>
  <script>
    // (removed) leaderboard and Supabase configuration/functions

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
  // Render-time zoom (uniform) — apply only on mobile-sized viewports
  const CAMERA_ZOOM = 1.2; // show ~1.2x more (zoom out on mobile)
  function getDrawScale() { return isMobile ? (1 / CAMERA_ZOOM) : 1; }
  function viewWidth() { return canvas.width / getDrawScale(); }
  function viewHeight() { return canvas.height / getDrawScale(); }
    // Determine mobile/desktop purely by viewport width (matching the CSS breakpoint)
    function computeIsMobile() {
      const vw = (window.visualViewport?.width || window.innerWidth);
      return vw <= 600;
    }
  // Width-based mobile flag (<= 600px)
  let isMobile = computeIsMobile();
  // Soft minimum play area height (px). Prefer at least this much canvas height
  // when space allows, but never exceed available viewport height.
  const MIN_PLAY_HEIGHT = 300;
  const titleImgEl = document.getElementById('titleImage');
  const topbarEl = document.getElementById('topbar');
    const controlsEl = document.getElementById('controls');
  const desktopInstrEl = document.getElementById('desktop-instructions');

    // Responsive sizing: fill available viewport between title and controls
  function sizeCanvasToViewport() {
      // Use visualViewport when available to account for mobile browser UI
  const vw = (window.visualViewport?.width || window.innerWidth);
  const vh = (window.visualViewport?.height || window.innerHeight);

      // Measure occupied vertical space (title + music bar + margins)
  const titleH = 0; // title is measured as part of the topbar
  const musicH = 0; // music bar measured via topbar
  const topbarH = topbarEl?.offsetHeight || 0;
  const controlsH = controlsEl?.offsetHeight || 0;
  const instrH = desktopInstrEl?.offsetHeight || 0;
  // Account for body padding defined in CSS (e.g., 24px and safe-area). Use computed style to be accurate.
  const cs = getComputedStyle(document.body);
  const padTop = parseFloat(cs.paddingTop) || 0;
  const padBottom = parseFloat(cs.paddingBottom) || 0;
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padRight = parseFloat(cs.paddingRight) || 0;
  const bodyGap = 8; // small gaps between sections

      // Available height for canvas: viewport minus occupied elements and small gaps
      // Do not enforce a large minimum here; keep canvas within available viewport so
      // controls (mobile) or instructions (desktop) always remain visible.
      const availableH = Math.max(0, vh - (padTop + padBottom + topbarH + controlsH + instrH + bodyGap * 4));

  const isSmall = vw <= 600;
  // Width/Height rules:
  // - Small screens: fill width and use available height
  // - Desktop: keep width 400, but cap height to available space (<= 600)
  // Apply soft minimum height so play area doesn't get too tiny.
  const targetW = isSmall ? Math.max(200, vw - (padLeft + padRight)) : 400;
  const desiredH = isSmall ? availableH : Math.min(600, availableH);
  const minH = Math.min(MIN_PLAY_HEIGHT, availableH);
  const targetH = Math.max(minH, desiredH);

      // Set CSS size for layout
      canvas.style.width = targetW + 'px';
      canvas.style.height = targetH + 'px';

      // Use logical pixel dimensions for internal canvas to keep physics in sync
      const logicalW = Math.round(targetW);
      const logicalH = Math.round(targetH);
      if (canvas.width !== logicalW || canvas.height !== logicalH) {
        canvas.width = logicalW;
        canvas.height = logicalH;
        // Reset any transforms after resize
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        // Ensure ground spans the new world width (accounts for zoom)
        if (ground) {
          ground.x = 0;
          ground.width = viewWidth();
        }
      }
      // Keep desktop instructions aligned with canvas left edge and width
      layoutDesktopInstructionsToCanvas();
    }

  // Align desktop instructions' left edge with the canvas and match its width
  function layoutDesktopInstructionsToCanvas() {
    if (!desktopInstrEl || !canvas) return;
    const cssW = canvas.style.width || (canvas.width + 'px');
    desktopInstrEl.style.width = cssW;
    desktopInstrEl.style.textAlign = 'center';
  }

  // Shared bold font stack for HUD/overlays
    const FONT_STACK_BOLD = 'Arial Black, Arial, Helvetica, sans-serif';
  const INSTR_TEXT = 'Use \u2190 and \u2192 to move. Press Space to jump.'; // ← →

    // --- Simple SoundCloud music player (hidden iframe) ---
    let scWidget = null;
  const scIframe = document.getElementById('sc-widget');
  const musicIcon = document.getElementById('music-icon');
  const musicIconPath = document.getElementById('music-icon-path');
    const musicScope = document.getElementById('music-scope');
    const scopeCtx = musicScope?.getContext('2d') || null;
    let scopeAnimId = null;
    let tick = 0;

    function drawBars() {
      if (!scopeCtx || !musicScope) return;
      const w = musicScope.width, h = musicScope.height;
      scopeCtx.clearRect(0, 0, w, h);
      // Parameters for 6 tiny bars
      const bars = 6;
      const gap = 2;
      const bw = Math.floor((w - gap * (bars - 1)) / bars);
  const isPlaying = musicIcon?.dataset.state === 'playing';
      const minPx = 2; // minimal height for paused bars
      for (let i = 0; i < bars; i++) {
        // When paused, show uniform minimal bars; when playing, vary heights over time
        let barH;
        if (!isPlaying) {
          barH = minPx;
        } else {
          const base = 0.25; // base relative height
          const amp = 0.6;
          const val = base + amp * (0.5 + 0.5 * Math.sin((tick * 0.15) + i * 0.9));
          barH = Math.max(minPx, Math.min(h, Math.round(val * h)));
        }
        const x = i * (bw + gap);
        const y = h - barH;
        scopeCtx.fillStyle = '#222';
        scopeCtx.fillRect(x, y, bw, barH);
      }
    }
    function startScope() {
      if (scopeAnimId) return;
      const step = () => {
        tick++;
        drawBars();
        scopeAnimId = requestAnimationFrame(step);
      };
      scopeAnimId = requestAnimationFrame(step);
    }
    function stopScope() {
      if (scopeAnimId) { cancelAnimationFrame(scopeAnimId); scopeAnimId = null; }
      drawBars();
    }
    let scReady = false;
    let desiredPlaying = false; // user's intended state; UI reflects actual state from widget

    function updateMusicUI(isPlaying) {
      if (!musicIcon) return;
      if (isPlaying) {
        musicIcon.dataset.state = 'playing';
        musicIcon.setAttribute('aria-label', 'Pause BGM');
        musicIcon.title = 'Pause BGM';
        if (musicIconPath) musicIconPath.setAttribute('d', 'M6 5h4v14H6zM14 5h4v14h-4z');
        startScope();
      } else {
        musicIcon.dataset.state = 'paused';
        musicIcon.setAttribute('aria-label', 'Play BGM');
        musicIcon.title = 'Play BGM';
        if (musicIconPath) musicIconPath.setAttribute('d', 'M8 5v14l11-7z');
        stopScope();
      }
    }

    function syncMusicStateFromWidget() {
      if (!scWidget) return;
      try {
        scWidget.isPaused((paused) => {
          updateMusicUI(!paused);
        });
      } catch(e) {}
    }
    function initMusic() {
      if (!window.SC || !scIframe) return;
      scWidget = SC.Widget(scIframe);
      scWidget.bind(SC.Widget.Events.READY, () => {
        scReady = true;
        // Ensure we start paused by default
        try { scWidget.pause(); } catch(e) {}
        desiredPlaying = false;
        if (musicIcon) {
          musicIcon.classList.remove('disabled');
        }
        // Initialize scope drawing (paused baseline) and sync UI from widget
        stopScope();
        syncMusicStateFromWidget();
      });

      // Reflect actual play/pause events from the widget
      scWidget.bind(SC.Widget.Events.PLAY, () => updateMusicUI(true));
      scWidget.bind(SC.Widget.Events.PAUSE, () => updateMusicUI(false));

      // Loop the same track when it finishes
      scWidget.bind(SC.Widget.Events.FINISH, () => {
        try {
          scWidget.seekTo(0);
          if (desiredPlaying) scWidget.play();
          else updateMusicUI(false);
        } catch(e) {}
      });

      musicIcon?.addEventListener('click', () => {
        if (!scReady) return;
        // Toggle desired state, but update UI only when widget confirms via events
        desiredPlaying = !desiredPlaying;
        // Attempt to unlock audio (user gesture)
        unlockAudioOnce();
        try {
          if (desiredPlaying) scWidget.play(); else scWidget.pause();
        } catch(e) {}
        // Fallback sync in case an event is missed (e.g., mobile autoplay quirks)
        setTimeout(syncMusicStateFromWidget, 500);
      });

      // While loading: leave button disabled
      if (musicIcon) { musicIcon.classList.add('disabled'); }
    }
    // Setup desktop vs mobile UI elements (controls vs instructions)
    function setupInputUI() {
      if (isMobile) {
        // Mobile: show on-screen controls, hide desktop instructions
        controlsEl.style.display = 'flex';
        desktopInstrEl.style.display = 'none';
      } else {
        // Desktop: hide controls, show instructions in game font
        controlsEl.style.display = 'none';
        desktopInstrEl.style.display = 'block';
        desktopInstrEl.style.marginTop = '10px';
        // Requested: Arial bold, 10pt, letter-spacing -25 (interpreted as -0.025em)
        desktopInstrEl.style.fontFamily = 'Arial, Helvetica, sans-serif';
        desktopInstrEl.style.fontWeight = '700';
        desktopInstrEl.style.fontSize = '10pt';
        desktopInstrEl.style.letterSpacing = '-0.025em';
        desktopInstrEl.style.color = '#000';
        desktopInstrEl.textContent = INSTR_TEXT;
        layoutDesktopInstructionsToCanvas();
        // On desktop, keyboard is the primary input.
      }
    }

    // -------- core tunables --------
  // These base values are tuned for ~60fps; we scale by dt in code paths below where needed.
  const gravity = 0.5;
  const playerSpeed = 3;
  const jumpPower = -20;

    // -------- ground --------
    const groundHeight = 24;
    const ground = { x: 0, y: 0, width: 400, height: groundHeight };
    let groundActive = true;

    // -------- player --------
    const player = {
      width: 32, height: 32,
      x: 0, y: 0,
      dx: 0, dy: 0,
      canJump: true
    };

    // -------- player sprites & animation --------
    // Actual files in sprites/player/:
    // Still_L.png, Still_R.png
    // JumpReady_L.png, JumpReady_R.png
    // Jump_L.png, Jump_R.png
    // Falling_L.png, Falling_R.png
    // Walking_L_1.png..Walking_L_4.png, Walking_R_1.png..Walking_R_4.png
  const SPRITE_BASE = 'resources/sprites/player/';
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }
    const playerAnim = {
      images: null,
      loaded: false,
      facing: 'R', // 'L' or 'R'
      state: 'still', // 'still' | 'walk' | 'jump-ready' | 'jump' | 'fall'
      walkFrameIndex: 0,
      walkTimer: 0,
      walkFrameDurationBase: 110, // ms at base speed
      jumpWindupMs: 50, // requested 50ms wind-up
      // async loading of all frames
  async load() {
        const files = {
          Still: { L: 'Still_L.png', R: 'Still_R.png' },
          JumpReady: { L: 'JumpReady_L.png', R: 'JumpReady_R.png' },
          Jump: { L: 'Jump_L.png', R: 'Jump_R.png' },
          Falling: { L: 'Falling_L.png', R: 'Falling_R.png' },
          Walking: {
            L: ['Walking_L_1.png','Walking_L_2.png','Walking_L_3.png'],
            R: ['Walking_R_1.png','Walking_R_2.png','Walking_R_3.png']
          }
        };
        const loadDir = async (name) => loadImage(SPRITE_BASE + name);
        const [stillL, stillR, jrL, jrR, jL, jR, fL, fR,
               wL1, wL2, wL3, wR1, wR2, wR3] = await Promise.all([
          loadDir(files.Still.L), loadDir(files.Still.R),
          loadDir(files.JumpReady.L), loadDir(files.JumpReady.R),
          loadDir(files.Jump.L), loadDir(files.Jump.R),
          loadDir(files.Falling.L), loadDir(files.Falling.R),
          loadDir(files.Walking.L[0]), loadDir(files.Walking.L[1]), loadDir(files.Walking.L[2]),
          loadDir(files.Walking.R[0]), loadDir(files.Walking.R[1]), loadDir(files.Walking.R[2])
        ]);
        this.images = {
          Still: { L: stillL, R: stillR },
          JumpReady: { L: jrL, R: jrR },
          Jump: { L: jL, R: jR },
          Falling: { L: fL, R: fR },
          Walking: { L: [wL1, wL2, wL3], R: [wR1, wR2, wR3] }
        };
        this.loaded = true;
      },
      // Update state and advance timers; physics: {dx, dy, canJump, windupActive}
      update(dt, physics) {
        if (!this.loaded) return;
        const EPS = 0.1;
        // facing follows movement when there's input
        if (Math.abs(physics.dx) > EPS) this.facing = physics.dx < 0 ? 'L' : 'R';
        // choose state
        if (physics.windupActive) {
          this.state = 'jump-ready';
        } else if (physics.canJump) {
          if (Math.abs(physics.dx) > EPS) {
            this.state = 'walk';
          } else {
            this.state = 'still';
          }
        } else {
          // airborne
          if (physics.dy < 0) this.state = 'jump'; else this.state = 'fall';
        }
        // walk frame timing: scale by horizontal speed
        if (this.state === 'walk') {
          const speed = Math.abs(physics.dx);
          const norm = Math.max(0.1, speed / playerSpeed);
          const frameDur = this.walkFrameDurationBase * (1 / Math.sqrt(norm));
          this.walkTimer += dt;
          const frameCount = 3;
          while (this.walkTimer >= frameDur) {
            this.walkTimer -= frameDur;
            this.walkFrameIndex = (this.walkFrameIndex + 1) % frameCount;
          }
        } else {
          // reset when switching out of walk for crisp restart
          this.walkTimer = 0;
          this.walkFrameIndex = 0;
        }
      },
      // Returns the current Image (or null) and draw offsets {ox, oy}
      getFrame() {
        if (!this.loaded || !this.images) return { img: null, ox: 0, oy: 0 };
        const dir = this.facing;
        let img = null;
        switch (this.state) {
          case 'jump-ready': img = this.images.JumpReady[dir]; break;
          case 'jump': img = this.images.Jump[dir]; break;
          case 'fall': img = this.images.Falling[dir]; break;
          case 'walk': img = this.images.Walking[dir][this.walkFrameIndex]; break;
          case 'still': default: img = this.images.Still[dir]; break;
        }
        return { img, ox: 0, oy: 0 };
      }
    };

  // -------- clouds --------
  const cloudWidth = 64, cloudHeight = 16;
  const CLOUD_TOP_RISE = 6; // visual top cap rises above base by 6px
  const CLOUD_OVERLAP_DRAW = 1; // draw player 1px into cloud for micro-overlap
  let clouds = [];
  let standingOnCloud = false; // frame flag for rendering micro-overlap

    // -------- difficulty (static) --------
  let MAX_CLOUD_SPACING = 150;
  let BASE_CLOUD_SPEED = 1.2;


  // milestone popup (every 1000 score)
  let milestonePopup = null;
  let nextMilestone = 1000;

    // restart cooldown (ms)
    let restartCooldown = 0;

  // (removed) leaderboard and player name state

  // Track if space is currently held
    let spaceHeld = false;

  // NEW: coyote time & jump buffer (ms)
  const COYOTE_TIME = 120; // ms
  const JUMP_BUFFER = 100; // ms
  let coyoteTimer = 0;     // counts down when leaving ground
  let jumpBufferTimer = 0; // counts down after early space press
  // Wind-up before liftoff (shows jump-ready sprite for 50ms)
  let jumpWindupTimer = 0; // ms left in wind-up; 0 when inactive

  // Pause flag (used later with future pause/mute work; currently not toggled)
  let paused = false;
    // --- particles ---
    const particles = [];
    function spawnPuff(x, y, count = 6, color = "#000000") {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          dx: (Math.random()*2-1) * 1.5,
          dy: -Math.random()*2 - 0.5,
          life: 300,
          color,
          size: 2 + Math.random()*2
        });
      }
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) { particles.splice(i,1); continue; }
        const step = dt/16.6667;
        p.x += p.dx * step;
        p.y += p.dy * step;
        p.dy += 0.05 * step;
      }
    }
    function drawParticles() {
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
      }
    }
    // Basic AudioContext SFX
    let audioCtx = null;
    let audioUnlocked = false;
    let sfxEnabled = true; // toggled by Start Menu
    function ensureAudio() {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { audioCtx = null; }
      }
    }
    function unlockAudioOnce() {
      ensureAudio();
      if (audioCtx && audioCtx.state !== 'running') {
        try { audioCtx.resume().catch(()=>{}); } catch(e) {}
      }
      audioUnlocked = true;
    }
    function beep(freq = 440, durMs = 100, type = "sine", gain = 0.05) {
      if (!sfxEnabled) return;
      ensureAudio();
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') {
        try { audioCtx.resume().catch(()=>{}); } catch(e) {}
      }
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g); g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.start(now);
      osc.stop(now + durMs/1000);
    }

    // Short musical cues
    function playLevelUpSFX() {
      // Uplifting rising triad
      beep(620, 70, "triangle", 0.04);
      setTimeout(() => beep(830, 80, "triangle", 0.038), 80);
      setTimeout(() => beep(1180, 90, "triangle", 0.035), 160);
    }
    function playGameOverSFX() {
      // Brief descending tones for a subtle disappointment
      beep(360, 110, "square", 0.04);
      setTimeout(() => beep(300, 120, "square", 0.035), 120);
      setTimeout(() => beep(240, 140, "square", 0.03), 240);
    }

    // -------- background gradient (drawn in pixel space) --------
    let bgOffset = 0; // retained for compatibility; not used by gradient
    function drawScrollingSky() {
      // Draw the sky in pixel coordinates so it always covers the entire canvas
      const w = canvas.width;
      const h = canvas.height;
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      
      // Progressively blend the bottom color towards white with score
      // t = 0 at score 0, t = 1 at score >= 10000
      const t = Math.max(0, Math.min(1, (score || 0) / 10000));
      const baseR = 0x5b, baseG = 0x86, baseB = 0xaa; // #5b86aa
      const r = Math.round(baseR + (255 - baseR) * t);
      const g = Math.round(baseG + (255 - baseG) * t);
      const b = Math.round(baseB + (255 - baseB) * t);
      const bottomColor = `rgb(${r},${g},${b})`;
      
      // Top (0) -> white, Bottom (1) -> blended bottomColor
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(1, bottomColor);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
    }

    function createCloud(y) {
      return {
        x: Math.random() * (viewWidth() - cloudWidth),
        y,
        width: cloudWidth,
        height: cloudHeight,
        dx: (Math.random() * BASE_CLOUD_SPEED + BASE_CLOUD_SPEED) * (Math.random() < 0.5 ? -1 : 1)
      };
    }

  // Clouds are spawned with initial spacing; no top-spawn tracker is used

    function initClouds() {
      clouds = [];
      const startY = ground.y - 80;
      for (let i = 0; i < 6; i++) {
        const spacing = (MAX_CLOUD_SPACING - 40) + Math.random() * 40;
        const y = startY - i * spacing;
        clouds.push(createCloud(y));
      }
    }

    // -------- game state --------
  let score = 0;
  let bestScore = Number(localStorage.getItem("cloudjump_best") || 0);
    let gameRunning = true;
    let gameOverSFXPlayed = false;
  let menuActive = true; // show start menu until Play
  const keys = {};

    // input
    window.addEventListener("keydown", e => {
      if (["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
      keys[e.code] = true;

      if (!gameRunning && e.code === "Space") {
        restartGame();
        keys["Space"] = false;
        spaceHeld = true; // treat it as held after restart
      }
      // Jump buffer: if space pressed while not currently able to jump, start/refresh buffer timer
      if (e.code === "Space") {
        jumpBufferTimer = JUMP_BUFFER;
      }
    });
    window.addEventListener("keyup", e => {
      if (["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
      keys[e.code] = false;

      if (e.code === "Space") {
        spaceHeld = false; // reset when released
      }
    });

      // Pause toggle
    window.addEventListener("keydown", e => {
      if (e.code === "KeyP") {
        paused = !paused;
      }
    });

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      
      if (!gameRunning) {
        // Check for restart button click
        const btnW = 110, btnH = 44;
        const btnX = canvas.width/2 - btnW/2;
        const btnY = getRestartButtonPosition();
        if (mx >= btnX && mx <= btnX+btnW && my >= btnY && my <= btnY+btnH) {
          restartGame();
        }
      }
    });

    // Also handle touch events for mobile
    canvas.addEventListener("touchend", e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.changedTouches[0];
      const mx = touch.clientX - rect.left;
      const my = touch.clientY - rect.top;
      
      if (!gameRunning) {
        // Check for restart button touch
        const btnW = 110, btnH = 44;
        const btnX = canvas.width/2 - btnW/2;
        const btnY = getRestartButtonPosition();
        if (mx >= btnX && mx <= btnX+btnW && my >= btnY && my <= btnY+btnH) {
          restartGame();
        }
      }
    });

    const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');
  const btnJump = document.getElementById('btn-jump');
  let desktopButtonsBound = false;

    function bindControl(el, onPress) {
      if (!el) return;
      // Prevent buttons from grabbing focus or triggering default text selection on drag
      el.addEventListener('mousedown', (e) => { e.preventDefault(); });
      el.addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });
      el.addEventListener('pointerdown', (e) => {
        el.setPointerCapture?.(e.pointerId);
        onPress(true);
        e.preventDefault();
      });
      el.addEventListener('pointerup', (e) => {
        onPress(false);
        e.preventDefault();
      });
      el.addEventListener('pointercancel', (e) => {
        onPress(false);
        e.preventDefault();
      });
      el.addEventListener('lostpointercapture', () => onPress(false));
      el.addEventListener('mouseleave', () => onPress(false));
    }

    // Left/Right buttons will be bound in setupInputUI() when in desktop mode
    bindControl(btnJump, (down) => {
      if (down) {
        jumpBufferTimer = JUMP_BUFFER; // buffer jump
        keys["Space"] = true;         // press Space
      } else {
        keys["Space"] = false;        // release Space
        spaceHeld = false;             // require fresh press
      }
    });

    // Sliding interaction for arrows: allows dragging finger between Left/Right seamlessly
    const arrowGroup = document.getElementById('arrow-group');
    if (arrowGroup) {
      let activeDir = null; // 'left' | 'right' | null
      let captured = false;
      let midX = null; // horizontal threshold for left/right
      let controllerPointerId = null; // the pointer that owns horizontal control

      // Avoid text selection/start drag when interacting with the arrow area
      arrowGroup.addEventListener('mousedown', (e) => { e.preventDefault(); });
      arrowGroup.addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });

      function setDir(dir) {
        if (dir === activeDir) return;
        // release previous
        keys["ArrowLeft"] = false;
        keys["ArrowRight"] = false;
        if (dir === 'left') keys["ArrowLeft"] = true;
        else if (dir === 'right') keys["ArrowRight"] = true;
        activeDir = dir;
      }

      function dirFromPoint(clientX) {
        // Determine left/right based on position relative to the group midpoint
        const rect = arrowGroup.getBoundingClientRect();
        const mid = (midX != null) ? midX : (rect.left + rect.width / 2);
        return clientX < mid ? 'left' : 'right';
      }

      arrowGroup.addEventListener('pointerdown', (e) => {
        arrowGroup.setPointerCapture?.(e.pointerId);
        captured = true;
        controllerPointerId = e.pointerId;
        // Cache the midpoint at gesture start
        const rect = arrowGroup.getBoundingClientRect();
        midX = rect.left + rect.width / 2;
        const dir = dirFromPoint(e.clientX);
        setDir(dir);
        e.preventDefault();
      });
      const onMove = (e) => {
        if (!captured || e.pointerId !== controllerPointerId) return;
        const dir = dirFromPoint(e.clientX);
        setDir(dir);
        e.preventDefault();
      };
      const onUp = (e) => {
        if (!captured || e.pointerId !== controllerPointerId) return;
        endSlide();
        e.preventDefault();
      };
  arrowGroup.addEventListener('pointermove', onMove);
  window.addEventListener('pointermove', onMove);
      function endSlide() {
        captured = false;
        midX = null;
        controllerPointerId = null;
        activeDir = null;
        keys["ArrowLeft"] = false;
        keys["ArrowRight"] = false;
      }
  arrowGroup.addEventListener('pointerup', onUp);
  window.addEventListener('pointerup', onUp);
  arrowGroup.addEventListener('pointercancel', onUp);
  window.addEventListener('pointercancel', onUp);
      arrowGroup.addEventListener('lostpointercapture', endSlide);
    }

    // (removed) player name management

  // (removed) leaderboard functions

    // Draw name prompt overlay
    // (removed) name prompt drawing and submission

    function restartGame() {
      ground.x = 0;
      ground.y = viewHeight() - groundHeight;
      ground.width = viewWidth();
      groundActive = true;

      player.x = viewWidth()/2 - player.width/2;
      player.y = ground.y - player.height;
      player.dx = 0; player.dy = 0; player.canJump = true;

  score = 0; gameRunning = true; bgOffset = 0; paused = false;
  MAX_CLOUD_SPACING = 150; BASE_CLOUD_SPEED = 1.2; milestonePopup = null; nextMilestone = 1000;

  // (removed) leaderboard state reset

      restartCooldown = 200;
      spaceHeld = false;
      coyoteTimer = 0;
      jumpBufferTimer = 0;
  jumpWindupTimer = 0;

      initClouds();
      gameOverSFXPlayed = false;
    }

  // Difficulty ramps with score thresholds (every 1000 points), without levels UI

    function update(dt) {
      if (menuActive) return; // freeze game until Play
      if (!gameRunning) {
        // Freeze popup state during game over
        return;
      }
      if (paused) return;

      const delta = Math.min(Math.max(dt, 0), 100);
      if (restartCooldown > 0) restartCooldown = Math.max(0, restartCooldown - delta);

      const prevY = player.y;
      const prevBottom = prevY + player.height;

      if (keys["ArrowLeft"]) player.dx = -playerSpeed;
      else if (keys["ArrowRight"]) player.dx = playerSpeed;
      else player.dx = 0;

      // Jump logic with coyote time, jump buffer, and wind-up
      // If space is currently held down, we do not consume it repeatedly; we rely on fresh press logic elsewhere.
      const wantsJump = (keys["Space"] && !spaceHeld) || jumpBufferTimer > 0;
      const canJumpNow = (player.canJump || coyoteTimer > 0) && restartCooldown <= 0;
      if (jumpWindupTimer > 0) {
        jumpWindupTimer = Math.max(0, jumpWindupTimer - delta);
        if (jumpWindupTimer === 0) {
          // liftoff occurs at wind-up completion if still allowed
          if (canJumpNow) {
            player.dy = jumpPower;
            player.canJump = false;
            beep(660, 90, "square", 0.04); // jump SFX at liftoff
            spawnPuff(player.x + player.width/2, player.y + player.height, 6, '#ffffff');
          }
        }
      } else if (wantsJump && canJumpNow) {
        // start wind-up
        jumpWindupTimer = playerAnim.jumpWindupMs;
        spaceHeld = keys["Space"]; // prevent immediate re-trigger while held
        jumpBufferTimer = 0; // consume buffer
      }

      // Time-based physics: scale by delta where appropriate
      const step = delta / 16.6667; // approx 60fps base
      player.dy += gravity * step;
      player.x += player.dx * step;
      player.y += player.dy * step;

  if (player.x < 0) player.x = 0;
  if (player.x + player.width > viewWidth()) player.x = viewWidth() - player.width;

      const currBottom = player.y + player.height;
      const wasCanJump = player.canJump;
      player.canJump = false;
      let onCloud = null;

      if (groundActive && currBottom >= ground.y && prevBottom <= ground.y) {
        player.dy = 0;
        player.y = ground.y - player.height;
        player.canJump = true;
        if (!wasCanJump) beep(220, 60, "sine", 0.03); // land SFX
        if (!wasCanJump) spawnPuff(player.x + player.width/2, player.y + player.height, 8, '#ffffff');
      }

      for (let cloud of clouds) {
        const surfaceY = cloud.y - CLOUD_TOP_RISE; // use visual top as landing surface
        if (
          currBottom >= surfaceY &&
          prevBottom <= surfaceY &&
          (player.x + player.width) > cloud.x &&
          player.x < cloud.x + cloud.width
        ) {
          player.dy = 0;
          player.y = surfaceY - player.height;
          player.canJump = true;
          onCloud = cloud;
          if (!wasCanJump) beep(220, 60, "sine", 0.03); // land SFX
          if (!wasCanJump) spawnPuff(player.x + player.width/2, player.y + player.height, 6, '#ffffff');
        }
      }

      if (onCloud) {
        player.x += onCloud.dx * step;
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > viewWidth()) player.x = viewWidth() - player.width;
      }

      // Track for rendering micro-overlap
      standingOnCloud = !!onCloud;

      // Update coyote/jump buffer timers
      if (player.canJump) {
        coyoteTimer = COYOTE_TIME; // reset while grounded
      } else {
        coyoteTimer = Math.max(0, coyoteTimer - delta);
      }
      if (!player.canJump && keys["Space"]) {
        // buffer already refreshed on keydown; here we keep it counting down
        jumpBufferTimer = Math.max(0, jumpBufferTimer - delta);
      } else if (!keys["Space"]) {
        // if not held, buffer should still count down
        jumpBufferTimer = Math.max(0, jumpBufferTimer - delta);
      }

  if (player.y < viewHeight() / 2) {
        const diff = (viewHeight() / 2) - player.y;
        player.y = viewHeight() / 2;

        for (let i = 0; i < clouds.length; i++) {
          clouds[i].y += diff;
          const visibleBottom = ground.y + ground.height; // bottom edge of the visible world
          // Despawn only when the entire cloud is below the bottom edge
          if ((clouds[i].y - CLOUD_TOP_RISE) >= visibleBottom) {
            clouds.splice(i, 1);
            const newY = -cloudHeight - Math.random()*40;
            clouds.push(createCloud(newY));
            i--;
          }
        }

        if (groundActive) {
          ground.y += diff;
          if (ground.y > viewHeight() + groundHeight) groundActive = false;
        }

        bgOffset = (bgOffset + diff/2);
        score += Math.floor(diff);
        // Trigger milestone popup for every 1000 points crossed
        while (score >= nextMilestone) {
          milestonePopup = { scoreNumber: nextMilestone, y: 72, alpha: 0.5 };
          playLevelUpSFX();
          nextMilestone += 1000;
        }
        // Difficulty scaling (same as previous level thresholds)
        const levelIndex = Math.floor(score / 1000); // 0 at 0..999, 1 at 1000..1999, etc.
        BASE_CLOUD_SPEED = 1.2 + (levelIndex) * 0.4;
        MAX_CLOUD_SPACING = 150 + (levelIndex) * 20;
      }

      for (let cloud of clouds) {
        cloud.x += cloud.dx * (delta / 16.6667);
        const right = cloud.x + cloud.width;
        // Robust bounce: clamp inside bounds and force velocity inward
        if (cloud.x < 0) {
          cloud.x = 0;
          cloud.dx = Math.abs(cloud.dx);
        } else if (right > viewWidth()) {
          cloud.x = viewWidth() - cloud.width;
          cloud.dx = -Math.abs(cloud.dx);
        }
      }

      // Die only after the player's top goes strictly below the visible bottom of the world
      const visibleBottom = ground.y + ground.height;
      if (player.y > visibleBottom) {
        if (!gameOverSFXPlayed) { playGameOverSFX(); gameOverSFXPlayed = true; }
        gameRunning = false;
        if (score > bestScore) {
          bestScore = score;
          try { localStorage.setItem("cloudjump_best", String(bestScore)); } catch(e) {}
        }
        // (removed) leaderboard submission and loading
      }

      if (milestonePopup) {
        milestonePopup.y -= 1;
        milestonePopup.alpha -= 0.02;
        if (milestonePopup.alpha <= 0) milestonePopup = null;
      }
      updateParticles(delta);
      // Update animation controller (after physics)
      playerAnim.update(delta, {
        dx: player.dx,
        dy: player.dy,
        canJump: player.canJump,
        windupActive: jumpWindupTimer > 0
      });
    }

    // -------- drawing --------
    function drawCloud(cloud) {
      // Original simple two-rectangle cloud with a single outer stroke around the combined shape
      ctx.fillStyle = "#fff";
      ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
      ctx.fillRect(cloud.x + 4, cloud.y - CLOUD_TOP_RISE, cloud.width - 8, cloud.height);

      const x = cloud.x, y = cloud.y, w = cloud.width, h = cloud.height;
      ctx.beginPath();
      // trace outer contour of the union of base rect and top rect
      ctx.moveTo(x, y + h);                // bottom-left
      ctx.lineTo(x, y);                    // up left edge to top of base
      ctx.lineTo(x + 4, y);                // to start of top rect inset
  ctx.lineTo(x + 4, y - CLOUD_TOP_RISE);            // up to top rect top edge
  ctx.lineTo(x + w - 4, y - CLOUD_TOP_RISE);        // across top edge of top rect
      ctx.lineTo(x + w - 4, y);            // down to top of base at right inset
      ctx.lineTo(x + w, y);                // to right edge
      ctx.lineTo(x + w, y + h);            // down to bottom-right
      ctx.closePath();
      ctx.strokeStyle = "#b0b7c2"; // thin light grey
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    // Concrete ground style with cracks texture
    let concretePattern = null;
    function getConcretePattern() {
      if (concretePattern) return concretePattern;
      const off = document.createElement('canvas');
      off.width = 64; off.height = 64;
      const c = off.getContext('2d');
      // base concrete color
      c.fillStyle = '#4a4f57';
      c.fillRect(0, 0, off.width, off.height);
      // subtle noise speckles
      const imgData = c.getImageData(0,0,off.width,off.height);
      for (let i = 0; i < imgData.data.length; i += 4) {
        const n = (Math.random()*30)|0; // 0..29
        imgData.data[i]   = Math.max(0, imgData.data[i]   - n);
        imgData.data[i+1] = Math.max(0, imgData.data[i+1] - n);
        imgData.data[i+2] = Math.max(0, imgData.data[i+2] - n);
      }
      c.putImageData(imgData, 0, 0);
      // cracks: draw randomized branched lines
      c.strokeStyle = 'rgba(20,22,25,0.6)';
      c.lineWidth = 1;
      c.lineCap = 'round';
      function crack(x, y, len, angle, depth=0) {
        c.beginPath();
        c.moveTo(x, y);
        const step = 4 + Math.random()*3;
        let cx = x, cy = y, a = angle;
        for (let t = 0; t < len; t += step) {
          a += (Math.random()-0.5) * 0.3; // slight jitter
          cx += Math.cos(a) * step;
          cy += Math.sin(a) * step;
          c.lineTo(cx, cy);
          // occasional branch
          if (depth < 2 && Math.random() < 0.1) {
            crack(cx, cy, len * 0.25, a + (Math.random()<0.5?-1:1)*(0.6+Math.random()*0.6), depth+1);
          }
        }
        c.stroke();
      }
      for (let i = 0; i < 6; i++) {
        const sx = Math.random()*off.width;
        const sy = Math.random()*off.height;
        const ang = Math.random()*Math.PI*2;
        crack(sx, sy, 36 + Math.random()*28, ang);
      }
      concretePattern = ctx.createPattern(off, 'repeat');
      return concretePattern;
    }

    function drawGround() {
      if (!groundActive) return;
      // fill with dark concrete base
      ctx.fillStyle = '#3f444b';
      ctx.fillRect(0, ground.y, viewWidth(), ground.height);
      // overlay cracks pattern
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = getConcretePattern();
      ctx.fillRect(0, ground.y, viewWidth(), ground.height);
      ctx.restore();
      // subtle top highlight to separate from air
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(0, ground.y, viewWidth(), 3);
    }
    function drawPlayer() {
      const yOff = standingOnCloud ? CLOUD_OVERLAP_DRAW : 0;
      // Try sprite first
      const { img } = playerAnim.getFrame();
      if (img) {
        // bottom-center align sprite to player's collision box
        const drawX = Math.round(player.x + player.width/2 - img.width/2);
        const drawY = Math.round(player.y + yOff + player.height - img.height);
        ctx.drawImage(img, drawX, drawY);
        return;
      }
      // Fallback: original rectangle placeholder if images not loaded yet
      ctx.fillStyle = "#000000";
      ctx.fillRect(player.x, player.y + yOff, player.width, player.height);
      ctx.fillStyle = "#000000";
      ctx.fillRect(player.x+8, player.y+8 + yOff, 16, 16);
    }
    function drawHUD() {
      // Helper for letter-spacing on canvas text
      function drawTextWithLetterSpacing(context, text, x, y, spacingPx) {
        let cx = Math.round(x);
        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          context.fillText(ch, cx, y);
          cx += Math.round(context.measureText(ch).width + spacingPx);
        }
      }
      const margin = 18; // 18px margin from edges
      // Score: Arial bold 24pt with letter spacing -100 (≈ -0.1em)
      const fontPt = 24;
      const ptToPx = 96/72; // CSS points to px
      const fontPx = Math.round(fontPt * ptToPx); // ~32px
      const spacingPx = -0.1 * fontPx; // -100 tracking ≈ -0.1em

      ctx.fillStyle = "#000";
      ctx.textAlign = 'left';
      const prevBaseline = ctx.textBaseline;
      ctx.textBaseline = 'top';
      ctx.font = `bold ${fontPt}pt Arial, Helvetica, sans-serif`;
      const scoreText = String(Math.floor(score));
      drawTextWithLetterSpacing(ctx, scoreText, margin, margin, spacingPx);

      // show pause indicator below score
      const pauseY = margin + fontPx + 2;
      ctx.font = `12px ${FONT_STACK_BOLD}`;
      if (paused) ctx.fillText("[Paused]", margin, pauseY);
      ctx.textBaseline = prevBaseline;
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      
      // Responsive font sizes for mobile
      const isMobileLayout = canvas.height < 600;
      const titleFont = isMobileLayout ? "28px" : "36px";
      const scoreFont = isMobileLayout ? "24px" : "30px";
      const standardFont = isMobileLayout ? "14px" : "16px";
      
      // Start layout from top with proper spacing
      let yPos = isMobileLayout ? 40 : 60;
      
      // Game Over title
      ctx.font = `${titleFont} ${FONT_STACK_BOLD}`;
      ctx.fillText("Game Over", canvas.width/2, yPos);
      yPos += isMobileLayout ? 35 : 50;
      
      // Current score
      ctx.font = `${scoreFont} ${FONT_STACK_BOLD}`;
      ctx.fillText(String(Math.floor(score)), canvas.width/2, yPos);
      yPos += isMobileLayout ? 30 : 40;
      
      // Best score
      ctx.font = `${standardFont} ${FONT_STACK_BOLD}`;
      ctx.fillText("Best: " + Math.floor(bestScore), canvas.width/2, yPos);
      yPos += isMobileLayout ? 25 : 35;
      // No leaderboard: leave clean space and move to restart
      
      // Add some padding before restart button
      yPos += isMobileLayout ? 15 : 20;
      
      // Restart button - positioned dynamically based on content above
      const btnW = 110, btnH = 44;
      const btnX = canvas.width/2 - btnW/2;
      const btnY = getRestartButtonPosition();
      
      ctx.fillStyle = "#222";
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.fillStyle = "#fff";
      ctx.font = `20px ${FONT_STACK_BOLD}`;
      ctx.fillText("Restart", canvas.width/2, btnY + btnH/2 + 7);

      // Controls hint
      ctx.font = `12px ${FONT_STACK_BOLD}`;
      if (!isMobile) {
        ctx.fillText("Press SPACE to Restart", canvas.width/2, btnY + btnH + 20);
      }

      ctx.textAlign = "left";
    }

    function getRestartButtonPosition() {
      // Position restart button comfortably below text, without leaderboard
      const isMobileLayout = canvas.height < 600;
      const bottomMargin = isMobileLayout ? 80 : 120;
      // target 65% height but ensure some bottom margin
      const target = Math.floor(canvas.height * 0.65);
      return Math.min(target, canvas.height - bottomMargin);
    }

    function draw() {
      // Clear in pixel space
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      // Ensure pixel art remains crisp
      if (ctx.imageSmoothingEnabled) ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Draw static sky background covering the entire canvas
      drawScrollingSky();

    // Compute world camera to keep the ground anchored to the pixel bottom
    const s = getDrawScale();
    const vw = viewWidth();
    const vh = viewHeight();
    // Align world x=0 to the left edge so the ground spans the visible width
    const camX = 0;
      const groundBottomWorld = ground.y + ground.height;
      const camY = groundBottomWorld - vh;  // place ground bottom at pixel bottom

      // Apply world transform (scale then translate in world units)
      ctx.setTransform(s, 0, 0, s, 0, 0);
      ctx.translate(-camX, -camY);

  // World rendering (background already drawn in pixel space)
      for (let cloud of clouds) drawCloud(cloud);
      drawGround();
      drawPlayer();
      drawParticles();

      // Reset to pixel space for HUD/overlays (keeps UI crisp and stable)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      drawHUD();

      if (milestonePopup) {
        ctx.fillStyle = `rgba(0, 0, 0, ${milestonePopup.alpha})`;
        ctx.textAlign = "center";
        const headlineSize = 28;
        ctx.font = `${headlineSize}px ${FONT_STACK_BOLD}`;
        ctx.fillText("SCORE", canvas.width/2, milestonePopup.y);
        const numberSize = 132;
        ctx.font = `${numberSize}px ${FONT_STACK_BOLD}`;
        const sub = String(milestonePopup.scoreNumber);
        const numberOffset = Math.max(110, Math.round(numberSize * 0.9));
        ctx.fillText(sub, canvas.width/2, milestonePopup.y + numberOffset);
        ctx.textAlign = "left";
      }

  if (!gameRunning && !menuActive) drawGameOver();
    }

    // -------- loop --------
    let lastTime = performance.now();
    function frame(now) {
      const dt = now - lastTime; lastTime = now;
      update(isNaN(dt) ? 16 : dt);
      draw();
      requestAnimationFrame(frame);
    }

    // Initialize music and start game loop
    function bootstrap() {
      sizeCanvasToViewport();
      initMusic();
      setupInputUI();
      // Begin loading player sprites (non-blocking)
      playerAnim.load().catch(() => { /* keep fallback rectangles */ });
      
      // Unlock WebAudio on first user interaction so SFX can play even if BGM stays off
      const unlockers = ['pointerdown', 'touchstart', 'keydown'];
      unlockers.forEach(ev => {
        window.addEventListener(ev, unlockAudioOnce, { once: true, passive: ev !== 'keydown' });
      });
      // Show menu and wait for Play to start the game loop state
      showStartMenu();
      requestAnimationFrame(frame);
    }
    // Resize handlers: refresh UI mode by width and resize canvas
    function refreshUIMode() {
      const newIsMobile = computeIsMobile();
      if (newIsMobile !== isMobile) {
        isMobile = newIsMobile;
        setupInputUI();
      }
      sizeCanvasToViewport();
      if (!isMobile) layoutDesktopInstructionsToCanvas();
    }
    window.addEventListener('resize', refreshUIMode);
    window.visualViewport?.addEventListener('resize', refreshUIMode);
    window.addEventListener('orientationchange', () => setTimeout(sizeCanvasToViewport, 100));
    // Kick off after layout settles
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(bootstrap, 0);
    } else {
      window.addEventListener('DOMContentLoaded', () => setTimeout(bootstrap, 0));
    }
  </script>
  <script>
    // ----- Start Menu logic -----
    const startMenu = document.getElementById('startMenu');
    const startMenuBackdrop = document.getElementById('startMenuBackdrop');
  const startMenuFrameImg = document.getElementById('startMenuFrame');
    const playBtn = document.getElementById('btn-play');
    const toggleMusicBtn = document.getElementById('toggle-music');
    const toggleSfxBtn = document.getElementById('toggle-sfx');

    function showStartMenu() {
      if (startMenuBackdrop) startMenuBackdrop.style.display = 'block';
      if (startMenuFrameImg) startMenuFrameImg.style.display = 'block';
      if (startMenu) startMenu.style.display = 'block';
      menuActive = true;
      // Initialize toggles: Music off, SFX on (reflect current states)
      updateMusicToggleUI(false);
      updateSfxToggleUI(sfxEnabled);
    }
    function hideStartMenu() {
      if (startMenuBackdrop) startMenuBackdrop.style.display = 'none';
      if (startMenuFrameImg) startMenuFrameImg.style.display = 'none';
      if (startMenu) startMenu.style.display = 'none';
      menuActive = false;
    }

    function updateMusicToggleUI(on) {
      if (!toggleMusicBtn) return;
      toggleMusicBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
      toggleMusicBtn.textContent = on ? 'On' : 'Off';
    }
    function updateSfxToggleUI(on) {
      if (!toggleSfxBtn) return;
      toggleSfxBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
      toggleSfxBtn.textContent = on ? 'On' : 'Off';
    }

    function setMusicEnabled(on) {
      desiredPlaying = !!on;
      try {
        if (scReady && scWidget) {
          if (on) scWidget.play(); else scWidget.pause();
        }
      } catch(e) {}
      // Sync icon/UI after widget processes
      setTimeout(syncMusicStateFromWidget, 200);
      updateMusicToggleUI(on);
    }

    if (playBtn) {
      playBtn.addEventListener('click', () => {
        hideStartMenu();
        restartGame();
      });
    }
    if (toggleMusicBtn) {
      toggleMusicBtn.addEventListener('click', () => {
        const next = toggleMusicBtn.getAttribute('aria-pressed') !== 'true';
        setMusicEnabled(next);
      });
    }
    if (toggleSfxBtn) {
      toggleSfxBtn.addEventListener('click', () => {
        sfxEnabled = !(toggleSfxBtn.getAttribute('aria-pressed') === 'true');
        updateSfxToggleUI(sfxEnabled);
        // give a tiny confirm ping when turning on
        if (sfxEnabled) beep(520, 70, 'square', 0.03);
      });
    }
  </script>
</body>
</html>
