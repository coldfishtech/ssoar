<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>SSOAR: Touch the Sky</title>
  <script src="https://w.soundcloud.com/player/api.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    html {
      background: #f6f8fb; /* subtle cool off-white */
    }
    body {
      margin: 0;
      background: #f6f8fb; /* subtle cool off-white */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    /* Prevent text/image selection and callouts during drag on mobile/desktop */
    html, body {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      /* Disable vertical dragging, allow only horizontal gestures */
      touch-action: pan-x;
    }
    #titleImage {
      width: 400px;
      max-width: 90vw;
      height: auto;
      image-rendering: pixelated;
      margin-bottom: 8px;
      -webkit-user-drag: none;
      user-select: none;
    }
    /* topbar wraps title + musicbar */
    #topbar {
      width: 400px;
      max-width: 90vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
  /* music bar (under title on desktop; next to it on mobile) */
    #musicbar {
      width: 400px;
      max-width: 90vw;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      /* Use the same bold font as the in-game text */
      font-family: Arial Black, Arial, Helvetica, sans-serif;
      font-weight: 900;
    }
  /* SVG play/pause icon (black) */
  #music-icon { width: 16px; height: 16px; cursor: pointer; display: inline-block; }
    #music-icon.disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }
    /* Ensure the label matches the icon/scope height visually */
    #music-label {
      font-family: Arial Black, Arial, Helvetica, sans-serif;
      font-weight: 900;
      font-size: 12px;
      color: #222;
      height: 28px;
      display: inline-flex;
      align-items: center;
    }
    /* Tiny frequency visualizer next to the music button */
    #music-scope {
      display: inline-block;
      width: 60px;
      height: 16px; /* match icon height */
      background: transparent;
      border: none !important; /* override global canvas border */
      box-shadow: none;
    }
    
    canvas {
      background: transparent; /* the canvas draws its own sky, page around is off-white */
      image-rendering: pixelated;
      border: 1px solid #b0b7c2; /* subtle cool grey stroke */
      -webkit-user-drag: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none; /* avoid scrolling/zoom while dragging on canvas */
    }
  /* Controls under the canvas (shown on mobile) */
    #controls {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none; /* avoid selecting/scrolling when sliding arrows */
    }
    .ctrl-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 1px solid #b0b7c2;
      background: #222;
      color: #fff;
      font: 24px/56px Arial, sans-serif;
      text-align: center;
      padding: 0;
      cursor: pointer;
      outline: none;
      margin: 0; /* eliminate default button margins */
      -webkit-user-drag: none;
      -webkit-tap-highlight-color: transparent;
    }
    /* arrows: pentagonal via clip-path; remove text visuals */
  .ctrl-arrow { width: 72px; height: 44px; border-radius: 0; font-size: 0; line-height: 0; }
  /* sleeker arrows: body extends fully to inner edge so no seam between buttons */
  .ctrl-arrow--right { clip-path: polygon(0% 0%, 82% 0%, 100% 50%, 82% 100%, 0% 100%); }
  .ctrl-arrow--left  { clip-path: polygon(100% 0%, 18% 0%, 0% 50%, 18% 100%, 100% 100%); }
    /* arrow group: tighter spacing and better touch handling */
    .ctrl-group-arrows {
      display: flex;
      gap: 2px;            /* slight visual separation */
      touch-action: none;  /* allow sliding without triggering page scroll/zoom */
    }
    /* jump (spacebar): keep circular but no symbol */
    .ctrl-btn--jump {
      width: 68px; height: 68px;
      border-radius: 50%;
      font-size: 0; line-height: 0;
      -webkit-appearance: none; appearance: none;
      clip-path: none; /* ensure no polygon shape leaks onto jump */
    }
    .ctrl-btn:active { filter: brightness(1.15); }

    /* Mobile-friendly layout: let elements span full width and canvas fill viewport remainder */
    @media (max-width: 600px) {
      body {
        align-items: stretch;
        justify-content: flex-start;
        padding: 24px;
        /* Extra bottom padding so bottom browser UI doesn't overlap controls */
        padding-bottom: 72px; /* fallback */
        padding-bottom: calc(72px + env(safe-area-inset-bottom)); /* add safe-area if present */
      }
      #topbar, #controls { width: 100%; max-width: 100%; box-sizing: border-box; }
      /* Place title and musicbar side-by-side on mobile */
      #topbar { flex-direction: row; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
      /* Half-size title image */
      #titleImage { width: 200px; max-width: 40vw; margin-bottom: 0; }
      /* Right-align music player so its right edge aligns with canvas right edge */
      #musicbar { margin-left: auto; margin-bottom: 0; box-sizing: border-box; padding: 0 0; gap: 8px; justify-content: flex-end; }
      /* Increase separation between arrow group and jump button */
      #controls { gap: 80px; }
      /* Canvas width will be set via JS; fallback respects body padding */
      canvas { width: 100%; height: auto; }
    }
  </style>
</head>
<body>
  <div id="topbar">
    <img id="titleImage" src="ssoar_title.png" alt="SSOAR Title" />
    <div id="musicbar" aria-label="Music Player">
      <span id="music-label">BGM</span>
      <svg id="music-icon" viewBox="0 0 24 24" aria-label="Play BGM" title="Play/Pause BGM" tabindex="-1" role="button" class="disabled" data-state="paused">
        <path id="music-icon-path" fill="#000" d="M8 5v14l11-7z"/>
      </svg>
      <canvas id="music-scope" width="60" height="16" aria-hidden="true"></canvas>
      <!-- hidden SoundCloud widget iframe used for playback/control -->
      <iframe
        id="sc-widget"
        allow="autoplay"
        scrolling="no"
        frameborder="no"
        style="position:absolute; left:-9999px; width:0; height:0; border:0;"
        src="https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/user-385939006/01-ddd&auto_play=false&hide_related=true&show_comments=false&show_user=false&show_reposts=false&visual=false">
      </iframe>
    </div>
  </div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  
  <!-- Leaderboard Modal -->
  <div id="leaderboard-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
    <div id="leaderboard-content" style="background: white; padding: 20px; border-radius: 8px; max-width: 400px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <h2 style="margin: 0 0 16px 0; font-family: Arial Black, Arial, sans-serif; text-align: center;">Leaderboard</h2>
      <div id="score-submission" style="margin-bottom: 20px; text-align: center;">
        <div style="margin-bottom: 12px; font-family: Arial Black, Arial, sans-serif; font-size: 18px;">
          Your Score: <span id="final-score">0</span>
        </div>
        <input type="text" id="player-name" placeholder="Enter your name" maxlength="20" 
               style="padding: 8px; font-size: 16px; border: 2px solid #ddd; border-radius: 4px; margin-right: 8px; width: 150px;">
        <button id="submit-score" style="padding: 8px 16px; font-size: 16px; background: #222; color: white; border: none; border-radius: 4px; cursor: pointer;">Submit</button>
      </div>
      <div id="leaderboard-list"></div>
      <div style="text-align: center; margin-top: 16px;">
        <button id="close-leaderboard" style="padding: 8px 16px; font-size: 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
      </div>
    </div>
  </div>

  <!-- Desktop instructions (hidden on mobile) -->
  <div id="desktop-instructions" aria-hidden="true" style="display:none;"></div>
  <div id="controls" aria-label="Game Controls">
    <div id="arrow-group" class="ctrl-group-arrows" aria-label="Directional Controls">
      <button id="btn-left" class="ctrl-btn ctrl-arrow ctrl-arrow--left" aria-label="Left" title="Left" tabindex="-1"></button>
      <button id="btn-right" class="ctrl-btn ctrl-arrow ctrl-arrow--right" aria-label="Right" title="Right" tabindex="-1"></button>
    </div>
    <button id="btn-jump" class="ctrl-btn ctrl-btn--jump" aria-label="Jump" title="Jump" tabindex="-1"></button>
  </div>
  <script>
    // -------- Supabase Configuration --------
    const SUPABASE_URL = 'https://yxwpfmkcdqenehspaguw.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4d3BmbWtjZHFlbmVoc3BhZ3V3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkyODk1MTcsImV4cCI6MjA3NDg2NTUxN30.Bn2Zu9LX0qvURFU6h0oEKtXvbsPsLEnYWIoL1NHesqs';
    
    let supabaseClient = null;
    let leaderboardEnabled = false;
    
    // Initialize Supabase client
    function initSupabase() {
      try {
        // Check if Supabase is available globally
        if (typeof supabase === 'undefined') {
          console.warn('Supabase library not loaded');
          leaderboardEnabled = false;
          return;
        }
        
        if (SUPABASE_URL !== 'YOUR_SUPABASE_URL_HERE' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY_HERE') {
          supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
          leaderboardEnabled = true;
          console.log('Supabase initialized successfully');
        } else {
          console.log('Supabase credentials not configured - leaderboard disabled');
          leaderboardEnabled = false;
        }
      } catch (error) {
        console.warn('Supabase initialization failed:', error);
        leaderboardEnabled = false;
      }
    }
    
    // Submit score to leaderboard
    async function submitScore(playerName, finalScore) {
      if (!leaderboardEnabled || !supabaseClient) return false;
      
      try {
        const { data, error } = await supabaseClient
          .from('leaderboard')
          .insert([{ player_name: playerName, score: finalScore }]);
        
        if (error) throw error;
        console.log('Score submitted:', finalScore);
        return true;
      } catch (error) {
        console.error('Error submitting score:', error);
        return false;
      }
    }
    
    // Get top scores from leaderboard
    async function getTopScores(limit = 10) {
      if (!leaderboardEnabled || !supabaseClient) return [];
      
      try {
        const { data, error } = await supabaseClient
          .from('leaderboard')
          .select('player_name, score, created_at')
          .order('score', { ascending: false })
          .limit(limit);
        
        if (error) throw error;
        return data || [];
      } catch (error) {
        console.error('Error fetching leaderboard:', error);
        return [];
      }
    }

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
  // Render-time zoom (uniform) — apply only on mobile-sized viewports
  const CAMERA_ZOOM = 1.2; // show ~1.2x more (zoom out on mobile)
  function getDrawScale() { return isMobile ? (1 / CAMERA_ZOOM) : 1; }
  function viewWidth() { return canvas.width / getDrawScale(); }
  function viewHeight() { return canvas.height / getDrawScale(); }
    // Determine mobile/desktop purely by viewport width (matching the CSS breakpoint)
    function computeIsMobile() {
      const vw = (window.visualViewport?.width || window.innerWidth);
      return vw <= 600;
    }
  // Width-based mobile flag (<= 600px)
  let isMobile = computeIsMobile();
  const titleImgEl = document.getElementById('titleImage');
  const topbarEl = document.getElementById('topbar');
    const controlsEl = document.getElementById('controls');
  const desktopInstrEl = document.getElementById('desktop-instructions');

    // Responsive sizing: fill available viewport between title and controls
  function sizeCanvasToViewport() {
      // Use visualViewport when available to account for mobile browser UI
  const vw = (window.visualViewport?.width || window.innerWidth);
  const vh = (window.visualViewport?.height || window.innerHeight);

      // Measure occupied vertical space (title + music bar + margins)
  const titleH = 0; // title is measured as part of the topbar
  const musicH = 0; // music bar measured via topbar
  const topbarH = topbarEl?.offsetHeight || 0;
  const controlsH = controlsEl?.offsetHeight || 0;
  const instrH = desktopInstrEl?.offsetHeight || 0;
  // Account for body padding defined in CSS (e.g., 24px and safe-area). Use computed style to be accurate.
  const cs = getComputedStyle(document.body);
  const padTop = parseFloat(cs.paddingTop) || 0;
  const padBottom = parseFloat(cs.paddingBottom) || 0;
  const padLeft = parseFloat(cs.paddingLeft) || 0;
  const padRight = parseFloat(cs.paddingRight) || 0;
  const bodyGap = 8; // small gaps between sections

      // Available height for canvas: viewport minus occupied elements and small gaps
  const availableH = Math.max(200, vh - (padTop + padBottom + topbarH + controlsH + instrH + bodyGap * 4));

  const isSmall = vw <= 600;
  // Width/Height rules: on small screens, fill width and available height; on desktop, keep original 400x600
  const targetW = isSmall ? Math.max(200, vw - (padLeft + padRight)) : 400;
  const targetH = isSmall ? availableH : 600;

      // Set CSS size for layout
      canvas.style.width = targetW + 'px';
      canvas.style.height = targetH + 'px';

      // Use logical pixel dimensions for internal canvas to keep physics in sync
      const logicalW = Math.round(targetW);
      const logicalH = Math.round(targetH);
      if (canvas.width !== logicalW || canvas.height !== logicalH) {
        canvas.width = logicalW;
        canvas.height = logicalH;
        // Reset any transforms after resize
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        // Ensure ground spans the new world width (accounts for zoom)
        if (ground) {
          ground.x = 0;
          ground.width = viewWidth();
        }
      }
    }

  // Shared bold font stack for HUD/overlays
    const FONT_STACK_BOLD = 'Arial Black, Arial, Helvetica, sans-serif';
  const INSTR_TEXT = 'Use \u2190 and \u2192 to move. Press Space to jump.'; // ← →

    // --- Simple SoundCloud music player (hidden iframe) ---
    let scWidget = null;
  const scIframe = document.getElementById('sc-widget');
  const musicIcon = document.getElementById('music-icon');
  const musicIconPath = document.getElementById('music-icon-path');
    const musicScope = document.getElementById('music-scope');
    const scopeCtx = musicScope?.getContext('2d') || null;
    let scopeAnimId = null;
    let tick = 0;

    function drawBars() {
      if (!scopeCtx || !musicScope) return;
      const w = musicScope.width, h = musicScope.height;
      scopeCtx.clearRect(0, 0, w, h);
      // Parameters for 6 tiny bars
      const bars = 6;
      const gap = 2;
      const bw = Math.floor((w - gap * (bars - 1)) / bars);
  const isPlaying = musicIcon?.dataset.state === 'playing';
      const minPx = 2; // minimal height for paused bars
      for (let i = 0; i < bars; i++) {
        // When paused, show uniform minimal bars; when playing, vary heights over time
        let barH;
        if (!isPlaying) {
          barH = minPx;
        } else {
          const base = 0.25; // base relative height
          const amp = 0.6;
          const val = base + amp * (0.5 + 0.5 * Math.sin((tick * 0.15) + i * 0.9));
          barH = Math.max(minPx, Math.min(h, Math.round(val * h)));
        }
        const x = i * (bw + gap);
        const y = h - barH;
        scopeCtx.fillStyle = '#222';
        scopeCtx.fillRect(x, y, bw, barH);
      }
    }
    function startScope() {
      if (scopeAnimId) return;
      const step = () => {
        tick++;
        drawBars();
        scopeAnimId = requestAnimationFrame(step);
      };
      scopeAnimId = requestAnimationFrame(step);
    }
    function stopScope() {
      if (scopeAnimId) { cancelAnimationFrame(scopeAnimId); scopeAnimId = null; }
      drawBars();
    }
    let scReady = false;
    let desiredPlaying = false; // user's intended state; UI reflects actual state from widget

    function updateMusicUI(isPlaying) {
      if (!musicIcon) return;
      if (isPlaying) {
        musicIcon.dataset.state = 'playing';
        musicIcon.setAttribute('aria-label', 'Pause BGM');
        musicIcon.title = 'Pause BGM';
        if (musicIconPath) musicIconPath.setAttribute('d', 'M6 5h4v14H6zM14 5h4v14h-4z');
        startScope();
      } else {
        musicIcon.dataset.state = 'paused';
        musicIcon.setAttribute('aria-label', 'Play BGM');
        musicIcon.title = 'Play BGM';
        if (musicIconPath) musicIconPath.setAttribute('d', 'M8 5v14l11-7z');
        stopScope();
      }
    }

    function syncMusicStateFromWidget() {
      if (!scWidget) return;
      try {
        scWidget.isPaused((paused) => {
          updateMusicUI(!paused);
        });
      } catch(e) {}
    }
    function initMusic() {
      if (!window.SC || !scIframe) return;
      scWidget = SC.Widget(scIframe);
      scWidget.bind(SC.Widget.Events.READY, () => {
        scReady = true;
        // Ensure we start paused by default
        try { scWidget.pause(); } catch(e) {}
        desiredPlaying = false;
        if (musicIcon) {
          musicIcon.classList.remove('disabled');
        }
        // Initialize scope drawing (paused baseline) and sync UI from widget
        stopScope();
        syncMusicStateFromWidget();
      });

      // Reflect actual play/pause events from the widget
      scWidget.bind(SC.Widget.Events.PLAY, () => updateMusicUI(true));
      scWidget.bind(SC.Widget.Events.PAUSE, () => updateMusicUI(false));

      // Loop the same track when it finishes
      scWidget.bind(SC.Widget.Events.FINISH, () => {
        try {
          scWidget.seekTo(0);
          if (desiredPlaying) scWidget.play();
          else updateMusicUI(false);
        } catch(e) {}
      });

      musicIcon?.addEventListener('click', () => {
        if (!scReady) return;
        // Toggle desired state, but update UI only when widget confirms via events
        desiredPlaying = !desiredPlaying;
        // Attempt to unlock audio (user gesture)
        unlockAudioOnce();
        try {
          if (desiredPlaying) scWidget.play(); else scWidget.pause();
        } catch(e) {}
        // Fallback sync in case an event is missed (e.g., mobile autoplay quirks)
        setTimeout(syncMusicStateFromWidget, 500);
      });

      // While loading: leave button disabled
      if (musicIcon) { musicIcon.classList.add('disabled'); }
    }
    // Setup desktop vs mobile UI elements (controls vs instructions)
    function setupInputUI() {
      if (isMobile) {
        // Mobile: show on-screen controls, hide desktop instructions
        controlsEl.style.display = 'flex';
        desktopInstrEl.style.display = 'none';
      } else {
        // Desktop: hide controls, show instructions in game font
        controlsEl.style.display = 'none';
        desktopInstrEl.style.display = 'block';
        desktopInstrEl.style.marginTop = '10px';
        desktopInstrEl.style.fontFamily = FONT_STACK_BOLD;
        desktopInstrEl.style.fontWeight = '900';
        desktopInstrEl.style.fontSize = '14px';
        desktopInstrEl.style.color = '#000';
        desktopInstrEl.textContent = INSTR_TEXT;
        // On desktop, keyboard is the primary input.
      }
    }
    // Removed setMuted; we no longer support mute, only play/pause


    // -------- core tunables --------
  // These base values are tuned for ~60fps; we scale by dt in code paths below where needed.
  const gravity = 0.5;
  const playerSpeed = 3;
  const jumpPower = -20;

    // -------- ground --------
    const groundHeight = 24;
    const ground = { x: 0, y: 0, width: 400, height: groundHeight };
    let groundActive = true;

    // -------- player --------
    const player = {
      width: 32, height: 32,
      x: 0, y: 0,
      dx: 0, dy: 0,
      canJump: true
    };

  // -------- clouds --------
  const cloudWidth = 64, cloudHeight = 16;
  const CLOUD_TOP_RISE = 6; // visual top cap rises above base by 6px
  const CLOUD_OVERLAP_DRAW = 1; // draw player 1px into cloud for micro-overlap
  let clouds = [];
  let standingOnCloud = false; // frame flag for rendering micro-overlap

    // -------- difficulty (static) --------
  let MAX_CLOUD_SPACING = 150;
  let BASE_CLOUD_SPEED = 1.2;


  // milestone popup (every 1000 score)
  let milestonePopup = null;
  let nextMilestone = 1000;

    // restart cooldown (ms)
    let restartCooldown = 0;

  // Leaderboard state
  let showLeaderboardOnGameOver = false;
  let leaderboardScoreSubmitted = false;

  // Track if space is currently held
    let spaceHeld = false;

  // NEW: coyote time & jump buffer (ms)
  const COYOTE_TIME = 120; // ms
  const JUMP_BUFFER = 100; // ms
  let coyoteTimer = 0;     // counts down when leaving ground
  let jumpBufferTimer = 0; // counts down after early space press

  // Pause flag (used later with future pause/mute work; currently not toggled)
  let paused = false;
    // --- particles ---
    const particles = [];
    function spawnPuff(x, y, count = 6, color = "#000000") {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          dx: (Math.random()*2-1) * 1.5,
          dy: -Math.random()*2 - 0.5,
          life: 300,
          color,
          size: 2 + Math.random()*2
        });
      }
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0) { particles.splice(i,1); continue; }
        const step = dt/16.6667;
        p.x += p.dx * step;
        p.y += p.dy * step;
        p.dy += 0.05 * step;
      }
    }
    function drawParticles() {
      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
      }
    }
    // Basic AudioContext SFX
    let audioCtx = null;
    let audioUnlocked = false;
    function ensureAudio() {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { audioCtx = null; }
      }
    }
    function unlockAudioOnce() {
      ensureAudio();
      if (audioCtx && audioCtx.state !== 'running') {
        try { audioCtx.resume().catch(()=>{}); } catch(e) {}
      }
      audioUnlocked = true;
    }
    function beep(freq = 440, durMs = 100, type = "sine", gain = 0.05) {
      ensureAudio();
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') {
        try { audioCtx.resume().catch(()=>{}); } catch(e) {}
      }
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g); g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.start(now);
      osc.stop(now + durMs/1000);
    }

    // Short musical cues
    function playLevelUpSFX() {
      // Uplifting rising triad
      beep(620, 70, "triangle", 0.04);
      setTimeout(() => beep(830, 80, "triangle", 0.038), 80);
      setTimeout(() => beep(1180, 90, "triangle", 0.035), 160);
    }
    function playGameOverSFX() {
      // Brief descending tones for a subtle disappointment
      beep(360, 110, "square", 0.04);
      setTimeout(() => beep(300, 120, "square", 0.035), 120);
      setTimeout(() => beep(240, 140, "square", 0.03), 240);
    }

    // -------- background stripes --------
    let bgOffset = 0;
    function drawScrollingSky() {
      const stripeHeight = 32;
      // Subtle cool near-white palette (very light blue/grey)
      const colors = ["#f4f8fc", "#f1f6fb", "#eef4f9", "#f1f6fb"];
      const h = viewHeight();
      const w = viewWidth();
      const total = Math.ceil(h / stripeHeight) + 2;
      for (let i = 0; i < total; i++) {
        const y = (i * stripeHeight + (bgOffset % (stripeHeight * colors.length) + stripeHeight * colors.length)) % (stripeHeight * colors.length);
        ctx.fillStyle = colors[i % colors.length];
        ctx.fillRect(0, y, w, stripeHeight);
      }
    }

    function createCloud(y) {
      return {
        x: Math.random() * (viewWidth() - cloudWidth),
        y,
        width: cloudWidth,
        height: cloudHeight,
        dx: (Math.random() * BASE_CLOUD_SPEED + BASE_CLOUD_SPEED) * (Math.random() < 0.5 ? -1 : 1)
      };
    }

  // Clouds are spawned with initial spacing; no top-spawn tracker is used

    function initClouds() {
      clouds = [];
      const startY = ground.y - 80;
      for (let i = 0; i < 6; i++) {
        const spacing = (MAX_CLOUD_SPACING - 40) + Math.random() * 40;
        const y = startY - i * spacing;
        clouds.push(createCloud(y));
      }
    }

    // -------- game state --------
  let score = 0;
  let bestScore = Number(localStorage.getItem("cloudjump_best") || 0);
    let gameRunning = true;
    let gameOverSFXPlayed = false;
  const keys = {};

    // input
    window.addEventListener("keydown", e => {
      if (["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
      keys[e.code] = true;

      if (!gameRunning && e.code === "Space") {
        restartGame();
        keys["Space"] = false;
        spaceHeld = true; // treat it as held after restart
      }
      // Jump buffer: if space pressed while not currently able to jump, start/refresh buffer timer
      if (e.code === "Space") {
        jumpBufferTimer = JUMP_BUFFER;
      }
    });
    window.addEventListener("keyup", e => {
      if (["ArrowLeft", "ArrowRight", "Space"].includes(e.code)) e.preventDefault();
      keys[e.code] = false;

      if (e.code === "Space") {
        spaceHeld = false; // reset when released
      }
    });

      // Pause toggle
    window.addEventListener("keydown", e => {
      if (e.code === "KeyP") {
        paused = !paused;
      }
    });

    canvas.addEventListener("click", e => {
      if (!gameRunning) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const btnW = 110, btnH = 44;
        const btnX = canvas.width/2 - btnW/2;
        const btnY = canvas.height/2 + 72;
        if (mx >= btnX && mx <= btnX+btnW && my >= btnY && my <= btnY+btnH) {
          restartGame();
        }
      }
    });

    // On-canvas touch overlay removed; using HTML controls under the canvas.

    // HTML controls (always visible under the canvas)
  const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');
  const btnJump = document.getElementById('btn-jump');
  let desktopButtonsBound = false;

    function bindControl(el, onPress) {
      if (!el) return;
      // Prevent buttons from grabbing focus or triggering default text selection on drag
      el.addEventListener('mousedown', (e) => { e.preventDefault(); });
      el.addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });
      el.addEventListener('pointerdown', (e) => {
        el.setPointerCapture?.(e.pointerId);
        onPress(true);
        e.preventDefault();
      });
      el.addEventListener('pointerup', (e) => {
        onPress(false);
        e.preventDefault();
      });
      el.addEventListener('pointercancel', (e) => {
        onPress(false);
        e.preventDefault();
      });
      el.addEventListener('lostpointercapture', () => onPress(false));
      el.addEventListener('mouseleave', () => onPress(false));
    }

    // Left/Right buttons will be bound in setupInputUI() when in desktop mode
    bindControl(btnJump, (down) => {
      if (down) {
        jumpBufferTimer = JUMP_BUFFER; // buffer jump
        keys["Space"] = true;         // press Space
      } else {
        keys["Space"] = false;        // release Space
        spaceHeld = false;             // require fresh press
      }
    });

    // Sliding interaction for arrows: allows dragging finger between Left/Right seamlessly
    const arrowGroup = document.getElementById('arrow-group');
    if (arrowGroup && btnLeft && btnRight) {
      let activeDir = null; // 'left' | 'right' | null
      let captured = false;
      let midX = null; // horizontal threshold for left/right
      let controllerPointerId = null; // the pointer that owns horizontal control

      // Avoid text selection/start drag when interacting with the arrow area
      arrowGroup.addEventListener('mousedown', (e) => { e.preventDefault(); });
      arrowGroup.addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });

      function setDir(dir) {
        if (dir === activeDir) return;
        // release previous
        keys["ArrowLeft"] = false;
        keys["ArrowRight"] = false;
        if (dir === 'left') keys["ArrowLeft"] = true;
        else if (dir === 'right') keys["ArrowRight"] = true;
        activeDir = dir;
      }

      function dirFromPoint(clientX) {
        // Determine left/right based on position relative to the group midpoint
        const rect = arrowGroup.getBoundingClientRect();
        const mid = (midX != null) ? midX : (rect.left + rect.width / 2);
        return clientX < mid ? 'left' : 'right';
      }

      arrowGroup.addEventListener('pointerdown', (e) => {
        arrowGroup.setPointerCapture?.(e.pointerId);
        captured = true;
        controllerPointerId = e.pointerId;
        // Cache the midpoint at gesture start
        const rect = arrowGroup.getBoundingClientRect();
        midX = rect.left + rect.width / 2;
        const dir = dirFromPoint(e.clientX);
        setDir(dir);
        e.preventDefault();
      });
      const onMove = (e) => {
        if (!captured || e.pointerId !== controllerPointerId) return;
        const dir = dirFromPoint(e.clientX);
        setDir(dir);
        e.preventDefault();
      };
      const onUp = (e) => {
        if (!captured || e.pointerId !== controllerPointerId) return;
        endSlide();
        e.preventDefault();
      };
      arrowGroup.addEventListener('pointermove', onMove);
      window.addEventListener('pointermove', onMove);
      function endSlide() {
        captured = false;
        midX = null;
        controllerPointerId = null;
        activeDir = null;
        keys["ArrowLeft"] = false;
        keys["ArrowRight"] = false;
      }
  arrowGroup.addEventListener('pointerup', onUp);
  window.addEventListener('pointerup', onUp);
  arrowGroup.addEventListener('pointercancel', onUp);
  window.addEventListener('pointercancel', onUp);
      arrowGroup.addEventListener('lostpointercapture', endSlide);
    }

    // -------- Leaderboard Functions --------
    function showLeaderboard(finalScore) {
      // Only show leaderboard if properly configured and enabled
      if (!leaderboardEnabled || !supabaseClient) {
        console.log('Leaderboard not available - Supabase not configured');
        return;
      }
      
      const modal = document.getElementById('leaderboard-modal');
      const finalScoreEl = document.getElementById('final-score');
      const playerNameInput = document.getElementById('player-name');
      const submitBtn = document.getElementById('submit-score');
      const closeBtn = document.getElementById('close-leaderboard');
      const scoreSubmissionDiv = document.getElementById('score-submission');
      
      // Ensure elements exist before proceeding
      if (!modal || !finalScoreEl || !playerNameInput || !submitBtn || !closeBtn) {
        console.error('Leaderboard elements not found');
        return;
      }
      
      finalScoreEl.textContent = finalScore;
      modal.style.display = 'flex';
      leaderboardScoreSubmitted = false;
      
      // Reset submission form
      scoreSubmissionDiv.style.display = 'block';
      playerNameInput.value = '';
      submitBtn.disabled = false;
      submitBtn.textContent = 'Submit';
      
      // Focus name input
      setTimeout(() => playerNameInput.focus(), 100);
      
      // Load and display current leaderboard
      loadLeaderboard();
      
      // Clear any existing event listeners to prevent duplicates
      submitBtn.onclick = null;
      closeBtn.onclick = null;
      playerNameInput.onkeypress = null;
      
      // Set up event listeners
      submitBtn.onclick = async () => {
        const playerName = playerNameInput.value.trim();
        if (!playerName) {
          alert('Please enter your name');
          return;
        }
        
        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';
        
        const success = await submitScore(playerName, finalScore);
        if (success) {
          scoreSubmissionDiv.style.display = 'none';
          leaderboardScoreSubmitted = true;
          loadLeaderboard(); // Refresh leaderboard
        } else {
          alert('Failed to submit score. Please try again.');
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit';
        }
      };
      
      closeBtn.onclick = () => {
        modal.style.display = 'none';
      };
      
      // Close modal when clicking outside the content
      modal.onclick = (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      };
      
      // Prevent closing when clicking inside the content
      const leaderboardContent = document.getElementById('leaderboard-content');
      if (leaderboardContent) {
        leaderboardContent.onclick = (e) => {
          e.stopPropagation();
        };
      }
      
      // Submit on Enter key
      playerNameInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          submitBtn.click();
        }
      };
    }
    
    async function loadLeaderboard() {
      const leaderboardList = document.getElementById('leaderboard-list');
      leaderboardList.innerHTML = '<div style="text-align: center; color: #666;">Loading...</div>';
      
      const scores = await getTopScores(10);
      
      if (scores.length === 0) {
        leaderboardList.innerHTML = '<div style="text-align: center; color: #666;">No scores yet. Be the first!</div>';
        return;
      }
      
      let html = '<div style="font-family: Arial Black, Arial, sans-serif; font-weight: bold; margin-bottom: 8px;">Top Scores:</div>';
      scores.forEach((entry, index) => {
        const rank = index + 1;
        const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
        html += `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid #eee;">
            <span style="font-weight: bold;">${medal} ${entry.player_name}</span>
            <span style="font-family: monospace;">${entry.score}</span>
          </div>
        `;
      });
      
      leaderboardList.innerHTML = html;
    }

    function restartGame() {
      ground.x = 0;
      ground.y = viewHeight() - groundHeight;
      ground.width = viewWidth();
      groundActive = true;

      player.x = viewWidth()/2 - player.width/2;
      player.y = ground.y - player.height;
      player.dx = 0; player.dy = 0; player.canJump = true;

  score = 0; gameRunning = true; bgOffset = 0; paused = false;
  MAX_CLOUD_SPACING = 150; BASE_CLOUD_SPEED = 1.2; milestonePopup = null; nextMilestone = 1000;

      restartCooldown = 200;
      spaceHeld = false;
      coyoteTimer = 0;
      jumpBufferTimer = 0;

      initClouds();
      gameOverSFXPlayed = false;
    }

  // Difficulty ramps with score thresholds (every 1000 points), without levels UI

    function update(dt) {
      if (!gameRunning) {
        // Freeze popup state during game over
        return;
      }
      if (paused) return;

      const delta = Math.min(Math.max(dt, 0), 100);
      if (restartCooldown > 0) restartCooldown = Math.max(0, restartCooldown - delta);

      const prevY = player.y;
      const prevBottom = prevY + player.height;

      if (keys["ArrowLeft"]) player.dx = -playerSpeed;
      else if (keys["ArrowRight"]) player.dx = playerSpeed;
      else player.dx = 0;

      // Jump logic with coyote time and jump buffer
      // If space is currently held down, we do not consume it repeatedly; we rely on fresh press logic elsewhere.
      const wantsJump = (keys["Space"] && !spaceHeld) || jumpBufferTimer > 0;
      const canJumpNow = (player.canJump || coyoteTimer > 0) && restartCooldown <= 0;
      if (wantsJump && canJumpNow) {
        player.dy = jumpPower;
        player.canJump = false;
        spaceHeld = keys["Space"]; // prevent immediate re-trigger while held
        jumpBufferTimer = 0; // consume buffer
        beep(660, 90, "square", 0.04); // jump SFX
        // jump puff (black)
        spawnPuff(player.x + player.width/2, player.y + player.height, 6);
      }

      // Time-based physics: scale by delta where appropriate
      const step = delta / 16.6667; // approx 60fps base
      player.dy += gravity * step;
      player.x += player.dx * step;
      player.y += player.dy * step;

  if (player.x < 0) player.x = 0;
  if (player.x + player.width > viewWidth()) player.x = viewWidth() - player.width;

      const currBottom = player.y + player.height;
      const wasCanJump = player.canJump;
      player.canJump = false;
      let onCloud = null;

      if (groundActive && currBottom >= ground.y && prevBottom <= ground.y) {
        player.dy = 0;
        player.y = ground.y - player.height;
        player.canJump = true;
        if (!wasCanJump) beep(220, 60, "sine", 0.03); // land SFX
        if (!wasCanJump) spawnPuff(player.x + player.width/2, player.y + player.height, 8);
      }

      for (let cloud of clouds) {
        const surfaceY = cloud.y - CLOUD_TOP_RISE; // use visual top as landing surface
        if (
          currBottom >= surfaceY &&
          prevBottom <= surfaceY &&
          (player.x + player.width) > cloud.x &&
          player.x < cloud.x + cloud.width
        ) {
          player.dy = 0;
          player.y = surfaceY - player.height;
          player.canJump = true;
          onCloud = cloud;
          if (!wasCanJump) beep(220, 60, "sine", 0.03); // land SFX
          if (!wasCanJump) spawnPuff(player.x + player.width/2, player.y + player.height, 6);
        }
      }

      if (onCloud) {
        player.x += onCloud.dx * step;
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > viewWidth()) player.x = viewWidth() - player.width;
      }

      // Track for rendering micro-overlap
      standingOnCloud = !!onCloud;

      // Update coyote/jump buffer timers
      if (player.canJump) {
        coyoteTimer = COYOTE_TIME; // reset while grounded
      } else {
        coyoteTimer = Math.max(0, coyoteTimer - delta);
      }
      if (!player.canJump && keys["Space"]) {
        // buffer already refreshed on keydown; here we keep it counting down
        jumpBufferTimer = Math.max(0, jumpBufferTimer - delta);
      } else if (!keys["Space"]) {
        // if not held, buffer should still count down
        jumpBufferTimer = Math.max(0, jumpBufferTimer - delta);
      }

      if (player.y < viewHeight() / 2) {
        const diff = (viewHeight() / 2) - player.y;
        player.y = viewHeight() / 2;

        for (let i = 0; i < clouds.length; i++) {
          clouds[i].y += diff;
          const visibleBottom = ground.y + ground.height; // bottom edge of the visible world
          // Despawn only when the entire cloud is below the bottom edge
          if ((clouds[i].y - CLOUD_TOP_RISE) >= visibleBottom) {
            clouds.splice(i, 1);
            const newY = -cloudHeight - Math.random()*40;
            clouds.push(createCloud(newY));
            i--;
          }
        }

        if (groundActive) {
          ground.y += diff;
          if (ground.y > viewHeight() + groundHeight) groundActive = false;
        }

        bgOffset = (bgOffset + diff/2);
        score += Math.floor(diff);
        // Trigger milestone popup for every 1000 points crossed
        while (score >= nextMilestone) {
          milestonePopup = { scoreNumber: nextMilestone, y: 72, alpha: 0.5 };
          playLevelUpSFX();
          nextMilestone += 1000;
        }
        // Difficulty scaling (same as previous level thresholds)
        const levelIndex = Math.floor(score / 1000); // 0 at 0..999, 1 at 1000..1999, etc.
        BASE_CLOUD_SPEED = 1.2 + (levelIndex) * 0.4;
        MAX_CLOUD_SPACING = 150 + (levelIndex) * 20;
      }

      for (let cloud of clouds) {
        cloud.x += cloud.dx * (delta / 16.6667);
        const right = cloud.x + cloud.width;
        // Robust bounce: clamp inside bounds and force velocity inward
        if (cloud.x < 0) {
          cloud.x = 0;
          cloud.dx = Math.abs(cloud.dx);
        } else if (right > viewWidth()) {
          cloud.x = viewWidth() - cloud.width;
          cloud.dx = -Math.abs(cloud.dx);
        }
      }

      // Die only after the player's top goes strictly below the visible bottom of the world
      const visibleBottom = ground.y + ground.height;
      if (player.y > visibleBottom) {
        if (!gameOverSFXPlayed) { playGameOverSFX(); gameOverSFXPlayed = true; }
        gameRunning = false;
        if (score > bestScore) {
          bestScore = score;
          try { localStorage.setItem("cloudjump_best", String(bestScore)); } catch(e) {}
        }
        // Show leaderboard modal after a short delay
        setTimeout(() => {
          showLeaderboard(Math.floor(score));
        }, 1000);
      }

      if (milestonePopup) {
        milestonePopup.y -= 1;
        milestonePopup.alpha -= 0.02;
        if (milestonePopup.alpha <= 0) milestonePopup = null;
      }
      updateParticles(delta);
    }

    // -------- drawing --------
    function drawCloud(cloud) {
      // Original simple two-rectangle cloud with a single outer stroke around the combined shape
      ctx.fillStyle = "#fff";
      ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
      ctx.fillRect(cloud.x + 4, cloud.y - CLOUD_TOP_RISE, cloud.width - 8, cloud.height);

      const x = cloud.x, y = cloud.y, w = cloud.width, h = cloud.height;
      ctx.beginPath();
      // trace outer contour of the union of base rect and top rect
      ctx.moveTo(x, y + h);                // bottom-left
      ctx.lineTo(x, y);                    // up left edge to top of base
      ctx.lineTo(x + 4, y);                // to start of top rect inset
  ctx.lineTo(x + 4, y - CLOUD_TOP_RISE);            // up to top rect top edge
  ctx.lineTo(x + w - 4, y - CLOUD_TOP_RISE);        // across top edge of top rect
      ctx.lineTo(x + w - 4, y);            // down to top of base at right inset
      ctx.lineTo(x + w, y);                // to right edge
      ctx.lineTo(x + w, y + h);            // down to bottom-right
      ctx.closePath();
      ctx.strokeStyle = "#b0b7c2"; // thin light grey
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    // Concrete ground style with cracks texture
    let concretePattern = null;
    function getConcretePattern() {
      if (concretePattern) return concretePattern;
      const off = document.createElement('canvas');
      off.width = 64; off.height = 64;
      const c = off.getContext('2d');
      // base concrete color
      c.fillStyle = '#4a4f57';
      c.fillRect(0, 0, off.width, off.height);
      // subtle noise speckles
      const imgData = c.getImageData(0,0,off.width,off.height);
      for (let i = 0; i < imgData.data.length; i += 4) {
        const n = (Math.random()*30)|0; // 0..29
        imgData.data[i]   = Math.max(0, imgData.data[i]   - n);
        imgData.data[i+1] = Math.max(0, imgData.data[i+1] - n);
        imgData.data[i+2] = Math.max(0, imgData.data[i+2] - n);
      }
      c.putImageData(imgData, 0, 0);
      // cracks: draw randomized branched lines
      c.strokeStyle = 'rgba(20,22,25,0.6)';
      c.lineWidth = 1;
      c.lineCap = 'round';
      function crack(x, y, len, angle, depth=0) {
        c.beginPath();
        c.moveTo(x, y);
        const step = 4 + Math.random()*3;
        let cx = x, cy = y, a = angle;
        for (let t = 0; t < len; t += step) {
          a += (Math.random()-0.5) * 0.3; // slight jitter
          cx += Math.cos(a) * step;
          cy += Math.sin(a) * step;
          c.lineTo(cx, cy);
          // occasional branch
          if (depth < 2 && Math.random() < 0.1) {
            crack(cx, cy, len * 0.25, a + (Math.random()<0.5?-1:1)*(0.6+Math.random()*0.6), depth+1);
          }
        }
        c.stroke();
      }
      for (let i = 0; i < 6; i++) {
        const sx = Math.random()*off.width;
        const sy = Math.random()*off.height;
        const ang = Math.random()*Math.PI*2;
        crack(sx, sy, 36 + Math.random()*28, ang);
      }
      concretePattern = ctx.createPattern(off, 'repeat');
      return concretePattern;
    }

    function drawGround() {
      if (!groundActive) return;
      // fill with dark concrete base
      ctx.fillStyle = '#3f444b';
      ctx.fillRect(0, ground.y, viewWidth(), ground.height);
      // overlay cracks pattern
      ctx.save();
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = getConcretePattern();
      ctx.fillRect(0, ground.y, viewWidth(), ground.height);
      ctx.restore();
      // subtle top highlight to separate from air
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(0, ground.y, viewWidth(), 3);
    }
    function drawPlayer() {
      const yOff = standingOnCloud ? CLOUD_OVERLAP_DRAW : 0;
      ctx.fillStyle = "#000000";
      ctx.fillRect(player.x, player.y + yOff, player.width, player.height);
      ctx.fillStyle = "#000000";
      ctx.fillRect(player.x+8, player.y+8 + yOff, 16, 16);
    }
    function drawHUD() {
      ctx.fillStyle = "#000";
      // Draw just the score number (32px)
      ctx.font = `32px ${FONT_STACK_BOLD}`;
      ctx.textAlign = 'left';
      ctx.fillText(String(Math.floor(score)), 10, 30);
      // show pause indicator below score
      ctx.font = `12px ${FONT_STACK_BOLD}`;
      if (paused) ctx.fillText("[Paused]", 10, 46);
    }
    // drawTouchControls removed
    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = `36px ${FONT_STACK_BOLD}`;
    ctx.fillText("Game Over", canvas.width/2, canvas.height/2 - 20);
  // Show the score number (30px)
  ctx.font = `30px ${FONT_STACK_BOLD}`;
  // Balanced vertical spacing between title, score, and best
  ctx.fillText(String(Math.floor(score)), canvas.width/2, canvas.height/2 + 16);
  // Best below the score
  ctx.font = `20px ${FONT_STACK_BOLD}`;
  ctx.fillText("Best: " + Math.floor(bestScore), canvas.width/2, canvas.height/2 + 52);

      const btnW=110, btnH=44;
  const btnX=canvas.width/2-btnW/2, btnY=canvas.height/2+72;
      ctx.fillStyle="#222"; ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.fillStyle="#fff"; ctx.font=`20px ${FONT_STACK_BOLD}`;
      ctx.fillText("Restart", canvas.width/2, btnY+btnH/2+7);

      // Only show keyboard hint on desktop
      if (!isMobile) {
        ctx.font=`16px ${FONT_STACK_BOLD}`;
        ctx.fillText("Press SPACE to Restart", canvas.width/2, btnY+btnH+28);
      }

      ctx.textAlign="left";
    }

    function draw() {
      // Clear in pixel space
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Compute world camera to keep the ground anchored to the pixel bottom
    const s = getDrawScale();
    const vw = viewWidth();
    const vh = viewHeight();
    // Align world x=0 to the left edge so the ground spans the visible width
    const camX = 0;
      const groundBottomWorld = ground.y + ground.height;
      const camY = groundBottomWorld - vh;  // place ground bottom at pixel bottom

      // Apply world transform (scale then translate in world units)
      ctx.setTransform(s, 0, 0, s, 0, 0);
      ctx.translate(-camX, -camY);

      // World rendering
      drawScrollingSky();
      for (let cloud of clouds) drawCloud(cloud);
      drawGround();
      drawPlayer();
      drawParticles();

      // Reset to pixel space for HUD/overlays (keeps UI crisp and stable)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      drawHUD();

      if (milestonePopup) {
        ctx.fillStyle = `rgba(0, 0, 0, ${milestonePopup.alpha})`;
        ctx.textAlign = "center";
        const headlineSize = 28;
        ctx.font = `${headlineSize}px ${FONT_STACK_BOLD}`;
        ctx.fillText("SCORE", canvas.width/2, milestonePopup.y);
        const numberSize = 132;
        ctx.font = `${numberSize}px ${FONT_STACK_BOLD}`;
        const sub = String(milestonePopup.scoreNumber);
        const numberOffset = Math.max(110, Math.round(numberSize * 0.9));
        ctx.fillText(sub, canvas.width/2, milestonePopup.y + numberOffset);
        ctx.textAlign = "left";
      }

      if (!gameRunning) drawGameOver();
    }

    // -------- loop --------
    let lastTime = performance.now();
    function frame(now) {
      const dt = now - lastTime; lastTime = now;
      update(isNaN(dt) ? 16 : dt);
      draw();
      requestAnimationFrame(frame);
    }

    // Initialize music and start game loop
    function bootstrap() {
      initSupabase();
      sizeCanvasToViewport();
      initMusic();
      setupInputUI();
      // Unlock WebAudio on first user interaction so SFX can play even if BGM stays off
      const unlockers = ['pointerdown', 'touchstart', 'keydown'];
      unlockers.forEach(ev => {
        window.addEventListener(ev, unlockAudioOnce, { once: true, passive: ev !== 'keydown' });
      });
      restartGame();
      requestAnimationFrame(frame);
    }
    // Resize handlers: refresh UI mode by width and resize canvas
    function refreshUIMode() {
      const newIsMobile = computeIsMobile();
      if (newIsMobile !== isMobile) {
        isMobile = newIsMobile;
        setupInputUI();
      }
      sizeCanvasToViewport();
    }
    window.addEventListener('resize', refreshUIMode);
    window.visualViewport?.addEventListener('resize', refreshUIMode);
    window.addEventListener('orientationchange', () => setTimeout(sizeCanvasToViewport, 100));
    // Kick off after layout settles
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(bootstrap, 0);
    } else {
      window.addEventListener('DOMContentLoaded', () => setTimeout(bootstrap, 0));
    }
  </script>
</body>
</html>
